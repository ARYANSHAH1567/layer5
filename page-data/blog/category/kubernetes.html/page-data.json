{"componentChunkName":"component---src-templates-blog-category-list-js","path":"/blog/category/kubernetes.html","result":{"data":{"allMdx":{"nodes":[{"id":"537177cb-afbd-5dc7-90e2-2c71c9eabf6b","body":"\n\n\n\n\n\n<BlogWrapper>\n\nKubernetes provides a Service to offer a unified traffic endpoint for the Pods. While it offers a VIP to the clients for access and Kubernetes ensures traffic balancing for the accessing back-end Pods, it has a limitation of routing traffic from outside the cluster. To overcome this issue, a new feature called \"NodePort\" has been introduced. \n\nBy setting up a mapping to a specific port of all nodes in the cluster, a NodePort Service redirects traffic from the outside to the inside of the cluster. When a NodePort Service is created, Kubernetes control plane allocates its corresponding ports in two ways. The first is dynamic, where Kubernetes control plane automatically assigns an unused port at the creation time. The second is static, which assigns a port within the nodeport port range configuration. It is crucial to assign a unique nodePort across the entire cluster while manually assigning nodePort, or it will result in an error if a service of type NodePort already uses that port. \n\nSometimes, there is a need to run a NodePort Service on well-known ports so that other components and users inside or outside the cluster can use them. In such cases, users need to reserve the required ports before using them. Kubernetes 1.27 introduced a new feature gate \"ServiceNodePortStaticSubrange\" that allows users to use a different port allocation strategy for type NodePort Services. Enabling this feature gate will divide the port range for NodePort Services based on a formula that uses nodeport size and determines the size of the static port range.\n\nHere are a few examples of different port ranges and their band offset values:\n<div className=\"table-3\">\n\n| Range properties | Values |\n| --- | --- |\n| service-node-port-range | 30000-32767 |\n| Band Offset | 86 |\n| Static band start | 30000 |\n| Static band end | 30085 |\n| Dynamic band start | 30086 |\n| Dynamic band end | 32767 |\n\n</div>\n<br />\n<div className=\"table-3\">\n\n| Range properties | Values |\n| --- | --- |\n| service-node-port-range | 30000-30015 |\n| Band Offset | 16 |\n| Static band start | 30000 |\n| Static band end | 30015 |\n| Dynamic band start | N/A |\n| Dynamic band end | N/A |\n\n</div>\n\nNodePort Services can be useful in many scenarios. For example, consider a user that needs to expose a Minio object storage service on Kubernetes to clients running outside the Kubernetes cluster. The agreed port is 30009, and the user needs to create a Service as follows:\n\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: minio\nspec:\n  ports:\n  - name: api\n    nodePort: 30009\n    port: 9000\n    protocol: TCP\n    targetPort: 9000\n  selector:\n    app: minio\n  type: NodePort\n```\nIf the port required for the Minio Service is not reserved and another NodePort (or possibly LoadBalancer) Service is created and dynamically allocated before or concurrently with the Minio Service, the TCP port 30009 might be allocated to that other Service. In this case, creation of the Minio Service will fail due to a node port collision. \n\nIn conclusion, using the NodePort Service will help Kubernetes users by allowing traffic to be routed from outside to inside the cluster, providing a unified traffic endpoint for the Pods. By enabling the ServiceNodePortStaticSubrange feature gate, users can adopt a different port allocation strategy, reducing the risk of collisions while using a different range of ports.\n\n</BlogWrapper>","frontmatter":{"title":"Kubernetes NodePorts - Static and Dynamic Assignments","subtitle":"Avoiding Port Collisions","date":"May 12th, 2023","author":"Lee Calcote","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRr4AAABXRUJQVlA4ILIAAABQBACdASoUABQAPtFcpU6oJSMiKAqpABoJagCdAA7o/xI+daMhu4ZyKIc8AP5sMkrm/KSMElhNhyFx1gsn7iAKtDbnb2EOpN1Lu4ERxHR8dZzo2nLfaBjTkL7HUoWJ2ZeN3kbroyt5qSiHJrjn1s8R/0YvwxgPzzQOJ6Z6/jny3fK+Q/p/RG8WRYpz7F7kTd49j//OPWbkB/vQwHCyP2a8pf47eyzW5wuh8SG+Fee1AAAA"},"images":{"fallback":{"src":"/static/7ff62eaeba27512aa31c04535a060e72/c1587/k8s-nodeports.webp","srcSet":"/static/7ff62eaeba27512aa31c04535a060e72/4f03f/k8s-nodeports.webp 750w,\n/static/7ff62eaeba27512aa31c04535a060e72/c1587/k8s-nodeports.webp 800w","sizes":"100vw"},"sources":[]},"width":1,"height":1}},"extension":"webp","publicURL":"/static/7ff62eaeba27512aa31c04535a060e72/k8s-nodeports.webp"},"darkthumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRr4AAABXRUJQVlA4ILIAAABQBACdASoUABQAPtFcpU6oJSMiKAqpABoJagCdAA7o/xI+daMhu4ZyKIc8AP5sMkrm/KSMElhNhyFx1gsn7iAKtDbnb2EOpN1Lu4ERxHR8dZzo2nLfaBjTkL7HUoWJ2ZeN3kbroyt5qSiHJrjn1s8R/0YvwxgPzzQOJ6Z6/jny3fK+Q/p/RG8WRYpz7F7kTd49j//OPWbkB/vQwHCyP2a8pf47eyzW5wuh8SG+Fee1AAAA"},"images":{"fallback":{"src":"/static/7ff62eaeba27512aa31c04535a060e72/5f169/k8s-nodeports.webp","srcSet":"/static/7ff62eaeba27512aa31c04535a060e72/d66e1/k8s-nodeports.webp 125w,\n/static/7ff62eaeba27512aa31c04535a060e72/e7160/k8s-nodeports.webp 250w,\n/static/7ff62eaeba27512aa31c04535a060e72/5f169/k8s-nodeports.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":500}},"extension":"webp","publicURL":"/static/7ff62eaeba27512aa31c04535a060e72/k8s-nodeports.webp"}},"fields":{"slug":"/blog/kubernetes/kubernetes-nodeports-static-and-dynamic-assignments"}},{"id":"dde8ee7a-cc39-5fd8-810b-96ca19b8760d","body":"\n\n\n\n\n<BlogWrapper>\n\nKubernetes is an open-source container orchestration system for automating the deployment, scaling, and management of containerized applications. As part of its functionality, Kubernetes offers a feature called \"Admission Controllers\" that allow administrators to enforce certain policies on resources being created in the cluster.\n\nIn this blog post, we will be discussing a new feature in Kubernetes called \"Validating Admission Policies\" which is currently in alpha stage. This feature allows administrators to define custom validation rules for resources being created in the cluster and enforce those rules using admission controllers.\n\n## What are Admission Controllers?\n\nAdmission controllers are pluggable components in the Kubernetes API server that intercept requests to create, update, or delete resources in the cluster. They allow administrators to enforce certain policies on these requests before they are persisted in the etcd database and acted upon by the Kubernetes control plane.\n\nThere are various types of admission controllers available in Kubernetes, such as:\n\n- **NamespaceLifecycle**: This admission controller enforces policies related to namespace creation and deletion.\n- **LimitRanger**: This admission controller enforces resource limits on pods, such as CPU and memory limits.\n- **PodSecurityPolicy**: This admission controller enforces security policies on pods, such as privileged mode, host networking, and volumes.\n\n## Validating Admission Policies\n\nValidating admission policies allow administrators to define custom validation rules for resources being created in the cluster. These rules can be defined using a custom resource definition (CRD) called \"ValidatingWebhookConfiguration\" and are enforced by the ValidatingAdmissionWebhook admission controller.\n\nFor example, an administrator may want to enforce a policy that requires all pods in the cluster to have a specific label. They can define this rule using a ValidatingWebhookConfiguration CRD and configure the ValidatingAdmissionWebhook admission controller to enforce it. Any request to create a pod that does not have the required label will be rejected by the admission controller.\n\nValidating admission policies also allow administrators to use external webhooks to perform the validation. This can be useful when the validation logic is complex or requires access to external resources.\n\n## Conclusion\n\nValidating admission policies is a new feature in Kubernetes that allows administrators to define custom validation rules for resources being created in the cluster. These rules can be enforced using the ValidatingAdmissionWebhook admission controller, and external webhooks can also be used for complex validation logic. This feature can be useful for enforcing policies and ensuring compliance in a Kubernetes cluster.\n\n</BlogWrapper>","frontmatter":{"title":"What are Kubernetes Validating Admission Controllers?","subtitle":"A close cousin to Validating Admission Webhooks","date":"February 3rd, 2023","author":"Lee Calcote","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRpwAAABXRUJQVlA4IJAAAABQBACdASoUABQAPtFgqE+oJSOiKAgBABoJbADBzYrIcLaTwo9+PMnGQagAAP72Av+XnXpDovXZeeq4tTUzLytHh8EOuq1sofHN2IthfXcoC9jFvtZhVo+tDrkfaFYPTkFWBWNyondfXcOX/mOVgrxqRCV7kvjREw4wZJCrfL9qeXzh9e/A/AD1++Ek5WwAAAA="},"images":{"fallback":{"src":"/static/0cda4651daf491c6b40dd404799ca32c/3987a/kubernetes-new.webp","srcSet":"/static/0cda4651daf491c6b40dd404799ca32c/4f03f/kubernetes-new.webp 750w,\n/static/0cda4651daf491c6b40dd404799ca32c/3987a/kubernetes-new.webp 900w","sizes":"100vw"},"sources":[]},"width":1,"height":1}},"extension":"webp","publicURL":"/static/0cda4651daf491c6b40dd404799ca32c/kubernetes-new.webp"},"darkthumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRnYBAABXRUJQVlA4WAoAAAAQAAAAEwAAEwAAQUxQSLAAAAABgCMAAOHmYpuT+YPkBckH7C1pf9Cp3TzZ7WTb7mTbdie7xzgPiIgJAFI1z5uhikYcXPkDLwoMuEisW//g9w4I3uWRw+GHvq+P22vn3u6v1eGkh+B09c3seN3vnzmc8QPs2S8sHRr4AjPDpYMP1a1lDfVV279D+DDZ4N3kZX3bTfvj9xwrjGwB/O3oWO94AsHzvWcLBmC6ACO8pmMB/kjSgLDErLKysrKigMdjJ4ZLqVZQOCCgAAAAUAQAnQEqFAAUAD7RXqhPqCSjoigIAQAaCWwAsQWgJYz3ksiGQV2/pilkAADsw+6hq/cA70EZQnxQiDQur0nITK3Vk/X0a4mvrPL9VqKWuo91tPOP2mzL3NrOliPXZ4F6vkz5Oquym+BBBVS4AM9mRrF3dykeG8Q5yHw80ozivZetdD37I5//8WlnKn5Zb4/XAc7vyMlQ8r7aCdP07KxAAA=="},"images":{"fallback":{"src":"/static/4fe429ff2237fa91df4168525bb25419/5f169/kubernetes-new-dark.webp","srcSet":"/static/4fe429ff2237fa91df4168525bb25419/d66e1/kubernetes-new-dark.webp 125w,\n/static/4fe429ff2237fa91df4168525bb25419/e7160/kubernetes-new-dark.webp 250w,\n/static/4fe429ff2237fa91df4168525bb25419/5f169/kubernetes-new-dark.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":500}},"extension":"webp","publicURL":"/static/4fe429ff2237fa91df4168525bb25419/kubernetes-new-dark.webp"}},"fields":{"slug":"/blog/kubernetes/what-are-kubernetes-validating-admission-controllers"}},{"id":"6a0f849a-8fcf-586a-9cf3-0beaac085455","body":"\n\n\n\n\n<BlogWrapper>\n<p>\nAs the final Kubernetes release of 2022, Kubernetes 1.26 is an exciting new release of the popular container orchestration platform. It offers a number of new features and improvements that will help platform engineers and DevOps engineers manage their Kubernetes clusters more effectively. Here are some of the highlights of this release. \n</p>\n<div className=\"intro\">\n  <p>\n    As a longstanding CNCF member, Layer5 has donated two of its open source projects to the CNCF: <Link to=\"/cloud-native-management/meshery\">Meshery</Link> and <Link to=\"/projects/service-mesh-performance\">Service Mesh Performance</Link>. As an end-to-end, open-source, multi-cluster Kuberentes management platform, Meshery makes Day 2 Kubernetes cluster management a breeze. Run Meshery to explore the behavorial changes of this Kubernetes release and what they really mean to you. \n  </p>\n</div>\n\nWhile there are a number of enhancments tracked in this release (38), you need to be aware that there are also a number of features being deprecated (10) in 1.26. In this article, we will focus on some highlighted enhancements, important deprecations, and removals so that you can be confident before upgrading your clusters. \n\nWe'll breakdown new K8s features by category, starting with networking.\n\n## Networking in Kubernetes 1.26\n\n### [Service Internal Traffic Policy](https://github.com/kubernetes/enhancements/issues/2086) [Stable]\n\nWhen requests are made to a Kubernetes service, they are randomly distributed to all available endpoints. The new enhancement enriches the API of a service to use node-local and topology-aware routing for internal traffic. The new internalTrafficPolicy field has two options: Cluster (default) and Local. The Cluster option works like before and tries distributing requests to all available endpoints. On the other hand, the Local option only sends requests to node-local endpoints and drops the request if there is no available instance on the same node. The Local option is useful for sending metrics or logs to an agent running as a DaemonSet. \n\n### [Reserve Service IP Ranges for Dynamic and Static IP Allocation](https://github.com/kubernetes/enhancements/issues/3070) [Stable]\n\nKubernetes services are assigned a virtual ClusterIP to be reachable inside the cluster. The ClusterIP is either assigned dynamically from a configured Service IP range, or statically set while creating the service resource. There was no possibility of knowing whether another service in the cluster had already used the static ClusterIP before this new stable enhancement. With this change, the IP range is divided into two; this prevents conflicts between services implementing dynamic IP allocation and static IP assignment. The flag --service-cluster-ip-range, with CIDR notation, is part of the Kubernetes API server configuration and is ready to use with the 1.26 release. \n\n### [Support of Mixed Protocols in Services with Type LoadBalancer](https://github.com/kubernetes/enhancements/issues/1435) [Stable]\n\nKubernetes Services that use the LoadBalancer type have only supported a single Layer 4 protocol until now. With this enhancement going from graduating to stable in v1.26, it is possible to define a mix of protocols in the same service definition. In other words, this enhancement allows a LoadBalancer Service to serve different protocols (e.g. UDP, TCP) under the same port (e.g. 443). For example, serving both UDP and TCP requests for a DNS or SIP server on the same port. For instance, you can expose a DNS server with a single load balancer IP for both TCP and UDP requests, such as the following:\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: multi-protocol-dns-server\nspec:\n  type: LoadBalancer\n  ports:\n    - name: dns-udp\n      port: 53\n      protocol: UDP\n    - name: dns-tcp\n      port: 53\n      protocol: TCP\n  selector:\n    app: dns-server\n```\n\n## Security in Kubernetes 1.26\n\n### [kubelet Credential Provider](https://github.com/kubernetes/enhancements/issues/2133) [Stable]\n\nThe kubelet agent has a built-in credential provider mechanism to retrieve credentials for container image registries. It natively supports Azure, Google Cloud, and AWS container image registries for dynamically retrieving their credentials. The new stable enhancement in v1.26 offers a replacement for the in-tree implementations, and creates an API for extensible plugins in the future. \n\n### [SignedSigning Release Artifacts](https://github.com/kubernetes/enhancements/issues/3031) [Beta]\n\nEvery Kubernetes release produces a set of artifacts such as binaries, container images, documentation, and metadata. Since the 1.24 release, the artifacts have been signed as an alpha feature. In the 1.26 release, artifact signing graduates to beta to increase software supply chain security for the Kubernetes release process and mitigate man-in-the-middle attacks.\n\n### [Reduction of Secret-Based Service Account Tokens](https://github.com/kubernetes/enhancements/issues/2799) [Beta]\n\n`BoundServiceAccountTokenVolume` has been GA since version 1.22: Service account tokens for pods are obtained via the TokenRequest API and stored as a projected volume. The new enhancement, in beta, eliminates the need to auto-generate secret-based service account tokens. In addition, Kubernetes will warn about using auto-created secret-based service account tokens, and purge the unused ones.\n\n### [Windows Privileged Containers](https://github.com/kubernetes/enhancements/issues/1981) [Stable] and [Host Networking](https://github.com/kubernetes/enhancements/issues/3503) [Alpha] \n\nPrivileged containers are the ones that have similar access and capabilities to the host processes running on the servers. In Linux environments, they are used heavily in Kubernetes for storage, networking, and management. In this release, support for privileged containers for the Windows environment graduates to stable. Management of processes is heavily different from the operating system standpoint in Linux and Windows. Therefore, privileged containers will also work differently in two environments, but they will ensure the same level of security and operational experience.\n\nIn addition, there is a new alpha-level enhancement in this release to support host networking for Windows pods. Currently, Windows has all the functionality to make containers use the networking namespace of the nodes. The new alpha enhancement enables this functionality from the Kubernetes side, increasing the parity between Linux and Windows containers.\n\n### [Self-User Attribute and Authentication API](https://github.com/kubernetes/enhancements/issues/33250) [Alpha] \n\nKubernetes has no resources to identify and manage users as part of its API. Instead, it uses authenticators to get user attributes from tokens, certificates, OIDC providers, or webhooks. The new alpha feature adds a new API endpoint to see what attributes the current users have. The new API is under authentication.k8s.io with the name SelfSubjectReview, and there is a new corresponding command as well: kubectl auth who-am-i. The new feature will reduce the obscurity of complex authentication and help users debug the authentication stack. \n\n## Scheduling in Kubernetes 1.26\n\n### [Non-Graceful Node Shutdown for StatefulSet Pods](https://github.com/kubernetes/enhancements/issues/2268) [Beta]\n\nAs a platform Kubernetes is hardened and has been deploy by thousands and thousands of users. Hardening of Kubernetes makes itself resistant to disasters. The kubelet agent that runs on each node in a Kubernetes cluster already uses graceful node shutdown to detect and offboard workloads to other nodes. However, when the shutdown is not detected by the kubelet, the pods of a `StatefulSet` are stuck as `Terminating` and not transferred to a healthy node. The kubelet on the downed node will not delete its pods from Kubernetes API, and the StatefulSet controller will not create new pods with the same name. This happens due to a conflict in the Kubernetes machinery. With this enhancement moving into beta, though, pods will be forcefully deleted along with their volume attachments and new pods will be migrated (created) on healthy nodes.\n\n### [Pod Scheduling Readiness](https://github.com/kubernetes/enhancements/issues/3521) [Alpha]\n\nCurrently, pods are considered ready for scheduling as soon as they are created. However, not every pod requires a node, resource allocation, and the start of all its containers immediately after its creation. The new alpha enhancement adds an API to mark pods with their scheduling status: paused and ready. Pods with the .spec.schedulingGates field will be parked in the scheduler and only be assigned to nodes when they are ready to be scheduled.\n\n### [kubectl explain to use OpenAPI v3 for ](https://github.com/kubernetes/enhancements/issues/3515) [Alpha]\n\nUse of OpenAPI v3 means supporting rich type information in `kubectl explan`. Kubernetes has supported OpenAPI v3 as a beta since version 1.24. This richer representation of the fields in the Kubernetes API, means that users can use the `kubectl explain` command to get information that is only detailed in  OpenAPI v3, and not the subset defined OpenAPI v2.\n\n## Deprecations and Removals\n\nConsistent to the Kubernetes API lifecycle is deprecations and removals of APIs in each release. It is strongly suggested to check whether you are using the following APIs and flags before there are breaking changes.\n\n<ul>\n<li>\n  Removal of the `flowcontrol.apiserver.k8s.io/v1beta1` API group for `FlowSchema` and `PriorityLevelConfiguration` requires a migration to the v1beta2 API version.\n</li>\n<li>\n  Removal of the `autoscaling/v2beta2` API version for HorizontalPodAutoscaler requires a migration to the autoscaling/v2 API version. \n</li>\n<li>\n  Removal of legacy and vendor-specific authentication client-go and kubectl for Azure and Google Cloud requires migration to vendor-neutral authentication plugin mechanisms.\n</li>\n<li>\n  Removal of in-tree CSI integration for OpenStack—namely, the `cinder` volume type—requires a migration to use the CSI driver for OpenStack. \n</li>\n<li>\n  Some unused options and flags for the kubectl run command are marked as deprecated in the 1.26 release, such as `--grace-period`, `--timeout`, and `--wait`.\n</li>\n</ul>\n\n## Last Kubernetes release of 2022\n\nKubernetes is an ever-evolving platform. For those of you running workloads on Kubernetes taking detailed note of API changes and enhancements is an important activity as you endevour to keep your clusters upgraded with release releases. A more secure, scalable, and flexible Kubernetes is our collective goal. Dign into more details about deprecation, removals, and the latest changes in the 1.26 [release notes](https://relnotes.k8s.io/).\n\nOn behalf of the Layer5 community and all of the CNCF projects that its contributors steward, thank you to everyone who participated in this Kubernetes release, and congratulations! \n\nAs an end-to-end, open-source, multi-cluster Kuberentes management platform, Meshery makes Day 2 Kubernetes cluster management a breeze. Run Meshery to explore the behavorial changes of this Kubernetes release and what they really mean to you. \n\n</BlogWrapper>\n","frontmatter":{"title":"Kubernetes 1.26 Highlights, Features, and Deprecations","subtitle":null,"date":"December 6th, 2022","author":"Lee Calcote","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRpwAAABXRUJQVlA4IJAAAABQBACdASoUABQAPtFgqE+oJSOiKAgBABoJbADBzYrIcLaTwo9+PMnGQagAAP72Av+XnXpDovXZeeq4tTUzLytHh8EOuq1sofHN2IthfXcoC9jFvtZhVo+tDrkfaFYPTkFWBWNyondfXcOX/mOVgrxqRCV7kvjREw4wZJCrfL9qeXzh9e/A/AD1++Ek5WwAAAA="},"images":{"fallback":{"src":"/static/0cda4651daf491c6b40dd404799ca32c/3987a/kubernetes-new.webp","srcSet":"/static/0cda4651daf491c6b40dd404799ca32c/4f03f/kubernetes-new.webp 750w,\n/static/0cda4651daf491c6b40dd404799ca32c/3987a/kubernetes-new.webp 900w","sizes":"100vw"},"sources":[]},"width":1,"height":1}},"extension":"webp","publicURL":"/static/0cda4651daf491c6b40dd404799ca32c/kubernetes-new.webp"},"darkthumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRnYBAABXRUJQVlA4WAoAAAAQAAAAEwAAEwAAQUxQSLAAAAABgCMAAOHmYpuT+YPkBckH7C1pf9Cp3TzZ7WTb7mTbdie7xzgPiIgJAFI1z5uhikYcXPkDLwoMuEisW//g9w4I3uWRw+GHvq+P22vn3u6v1eGkh+B09c3seN3vnzmc8QPs2S8sHRr4AjPDpYMP1a1lDfVV279D+DDZ4N3kZX3bTfvj9xwrjGwB/O3oWO94AsHzvWcLBmC6ACO8pmMB/kjSgLDErLKysrKigMdjJ4ZLqVZQOCCgAAAAUAQAnQEqFAAUAD7RXqhPqCSjoigIAQAaCWwAsQWgJYz3ksiGQV2/pilkAADsw+6hq/cA70EZQnxQiDQur0nITK3Vk/X0a4mvrPL9VqKWuo91tPOP2mzL3NrOliPXZ4F6vkz5Oquym+BBBVS4AM9mRrF3dykeG8Q5yHw80ozivZetdD37I5//8WlnKn5Zb4/XAc7vyMlQ8r7aCdP07KxAAA=="},"images":{"fallback":{"src":"/static/4fe429ff2237fa91df4168525bb25419/5f169/kubernetes-new-dark.webp","srcSet":"/static/4fe429ff2237fa91df4168525bb25419/d66e1/kubernetes-new-dark.webp 125w,\n/static/4fe429ff2237fa91df4168525bb25419/e7160/kubernetes-new-dark.webp 250w,\n/static/4fe429ff2237fa91df4168525bb25419/5f169/kubernetes-new-dark.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":500}},"extension":"webp","publicURL":"/static/4fe429ff2237fa91df4168525bb25419/kubernetes-new-dark.webp"}},"fields":{"slug":"/blog/kubernetes/kubernetes-126-highlights-features-and-deprecations"}},{"id":"ee4ff46e-ae65-555e-835d-ca9902fd8876","body":"\n<BlogWrapper>\n\n<p>As a platform for developers and system administrators to easily deploy and manage applications in a distributed environment, Kubernetes clusters generate logs and lots of them. One of the key components of Kubernetes is its logging and instrumentation capabilities. The upcoming Kubernetes 1.26 release has a handful of noteworthy changes to its system component logger, <code>klog</code>.</p>\n\n## Kubernetes System Log\n\nSystem component logs record events happening in K8s clusters. More than metrics or traces, logs are the telemetric signal often found to be most useful for debugging. You can configure K8s log verbosity to see more or less detail. Logs can be as coarse-grained as showing errors within a component, or as fine-grained as showing step-by-step traces of events (like HTTP access logs, pod state changes, controller actions, or scheduler decisions).\n\n## Klog\n\n[klog](https://github.com/kubernetes/klog) is a Kubernetes logging library that provides an API for developers and system administrators to instrument their applications for logging and tracing. klog generates log messages for the Kubernetes system components. It provides a comprehensive set of features, including log levels, structured logging and logging context.\n\nKubernetes 1.23 introduced structured logging (in beta) in `klog`. Structured logging is a uniform structure in log messages allowing for programmatic extraction of information. Structured logs can be stored and processed with less effort and cost. The code which generates a log message determines whether it uses the traditional unstructured `klog` output or structured logging.\n\nAs a dependency to structured logging (gated behind `StructuredLogging` feature gate), Kubernetes 1.24 introducted contextual logging (in alpha) in `klog`. Contextual logging builds on top of structured logging. It is primarily about how developers use logging calls: code based on that concept is more flexible and supports additional use cases which will be the topic of a future blog post. \n\n### Klog Deprecations in Kubernetes 1.26\n\nKubernetes has recently announced that it intends to deprecate certain flags related to Klog in its components. This means that Klog-specific flags, such as `--klog-verbosity`, `--klog-vmodule` and `--klog-stderrthreshold` will no longer be supported. This is due to the fact that Klog has been largely superseded by the more comprehensive OpenTelemetry project, which provides a more complete solution for logging and instrumentation.\n\nThe deprecation of Klog-specific flags is a positive step forward for Kubernetes as it moves to OpenTelemetry. This move will ensure that Kubernetes is using the industry-standard logging and instrumentation solution. It will also provide developers and system administrators with a more comprehensive, reliable and consistent experience when instrumenting their applications.\nA goal of this deprecation is one of unblocking development of alternative logging formats. Why does Kubnernetes need another logging format? One reason is performance. Klog performance is much worse than alternatives, for example 7-8x than JSON format:\n\n|logger                 |time [ns/op]|bytes[B/op]|allocations[alloc/op]|\n|-----------------------|------------|-----------|---------------------|\n|Text Infof             |2252        |248        |3                    |\n|Text InfoS             |2455        |280        |3                    |\n|JSON Infof             |1406        |19         |1                    |\n|JSON InfoS             |319         |67         |1                    |\n\nProof of concept implementation of new logging formats were completed to assess the potentional gains of using an alternative format. Results measured on 30s benchmark for passing 2 arguments to format function.\n\n<div className=\"tip\">\n<h3>Tip: Logger Performance Comparison</h3>\n\nInterestingly, Klog isn't the fastest logger in the West, but Uber's open source project [zap ](https://github.com/uber-go/zap) appears to hold that title instead. The following performance test benchmark is an examle of one of a number of scenarios in which loggers can be performance analyzed.\n\n<p>Log a message and 10 fields:</p>\n\n| Package             |    Time     | Time % to zap | Objects Allocated |\n| :------------------ | :---------: | :-----------: | :---------------: |\n| zap                 | 2900 ns/op  |      +0%      |    5 allocs/op    |\n| zap (sugared)       | 3475 ns/op  |     +20%      |   10 allocs/op    |\n| zerolog             | 10639 ns/op |     +267%     |   32 allocs/op    |\n| go-kit              | 14434 ns/op |     +398%     |   59 allocs/op    |\n| logrus              | 17104 ns/op |     +490%     |   81 allocs/op    |\n| apex/log            | 32424 ns/op |    +1018%     |   66 allocs/op    |\n| log15               | 33579 ns/op |    +1058%     |   76 allocs/op    |\n\n</div>\n\nOutput will always be written to stderr, regardless of the output format. Output redirection is expected to be handled by the component which invokes a Kubernetes component. This can be a POSIX shell or a tool like systemd.\n\nThe deprecation of Klog-specific flags is part of a larger effort to transition Kubernetes to a more modern and comprehensive logging and instrumentation solution. This will provide Kubernetes users with a more reliable, secure and consistent experience when instrumenting and monitoring their applications.\n\nKubernetes will continue to provide support for Klog-specific flags for the foreseeable future. However, it is recommended that developers and system administrators begin transitioning their applications to the OpenTelemetry framework. This will ensure that their applications are using the industry-standard solution for logging and instrumentation.\n\nOverall, the deprecation of Klog-specific flags is a positive step forward for Kubernetes. It will ensure that Kubernetes users have access to the most reliable and comprehensive solution for logging and instrumentation. It will also help ensure that Kubernetes is using the industry-standard solution and will provide developers and system administrators with a more reliable and consistent experience when instrumenting their applications.\n</BlogWrapper>","frontmatter":{"title":"Structured logging in Kubernetes with Klog","subtitle":"Deprecating Klog flags in Kubernetes 1.26","date":"December 5th, 2022","author":"Lee Calcote","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRo4AAABXRUJQVlA4IIIAAAAQBACdASoUABQAPtFYpUyoJSOiKA1RABoJbADE2A9oOHBqhtd/PoCpgAD+9hPef0TEKVio6tt3FOets66Z3rYkj6VKa9nnk5BswW619qW3HimtX50rDTgg73noredVBvmuHNfM92EZ3yl/IPFRzvtyYwEvFfOxgqRkERYrQM26gAAA"},"images":{"fallback":{"src":"/static/a125a7ad56dafd70886f09d8c408e114/3987a/kubernetes-logs.webp","srcSet":"/static/a125a7ad56dafd70886f09d8c408e114/4f03f/kubernetes-logs.webp 750w,\n/static/a125a7ad56dafd70886f09d8c408e114/3987a/kubernetes-logs.webp 900w","sizes":"100vw"},"sources":[]},"width":1,"height":1}},"extension":"webp","publicURL":"/static/a125a7ad56dafd70886f09d8c408e114/kubernetes-logs.webp"},"darkthumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRmwBAABXRUJQVlA4WAoAAAAQAAAAEwAAEwAAQUxQSLYAAAABgGNtm6rmnxncSt2Hyy7cNkClrbvuACqnooV4d0uquKfkUMYNnbknWUFETAD8a+TMU1M6mqgpleqTSb1Uqs7SJDlQXt/eXitBWGQyzyeTuZkHMiw4bmHgAST89BQmTMZCNlOoVguZhIihvDxdnhzNxr9LFQ2Vl51lu9UePvPgjo8PZqMvFnA0qWkpgziNdxKBmEGSg21y+fnu4iX8+Y0QmrhGMMZY/B0hQMeh8k4fAVaEdyL4S1ZQOCCQAAAA8AMAnQEqFAAUAD7RWqNNKCUjIigNUQAaCWwAvkgQ3sibXv8o78YB8AD+6/YtrSM9Rc5Lz22/yXt8aymW8E1+TIYMBxpYCXm0QnmjTq/+uaLWqy+vQVQ7N8FLsC99nCFhoHFMXPczNJAr19SR9ikZu45mfBuGjhMpGfqKbpZZoFUGz46t/rzj/oRetDiwAAAA"},"images":{"fallback":{"src":"/static/36fd87e316aac4b3df8f3b1a24a3ffeb/5f169/kubernetes-logs-dark.webp","srcSet":"/static/36fd87e316aac4b3df8f3b1a24a3ffeb/d66e1/kubernetes-logs-dark.webp 125w,\n/static/36fd87e316aac4b3df8f3b1a24a3ffeb/e7160/kubernetes-logs-dark.webp 250w,\n/static/36fd87e316aac4b3df8f3b1a24a3ffeb/5f169/kubernetes-logs-dark.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":500}},"extension":"webp","publicURL":"/static/36fd87e316aac4b3df8f3b1a24a3ffeb/kubernetes-logs-dark.webp"}},"fields":{"slug":"/blog/kubernetes/structured-logging-in-kubernetes-with-klog"}}]}},"pageContext":{"category":"Kubernetes"}},"staticQueryHashes":["1376321266","1485533831","2848499768","3205812809","4047814605","961506260"],"matchPath":"/blog/category/kubernetes"}