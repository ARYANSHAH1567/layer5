{"componentChunkName":"component---src-templates-learn-chapter-js-content-file-path-home-runner-work-layer-5-layer-5-content-learn-mastering-service-meshes-for-developers-introduction-to-service-meshes-linkerd-deploy-an-application-mdx","path":"/learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/deploy-an-application.html.html","result":{"data":{"chapter":{"body":"\n\n\n<ChapterStyle>\n\nTo play with Linkerd and demonstrate some of it's capabilities, you will deploy the sample application, EmojiVoto.\n\n<h2 className=\"chapter-sub-heading\">What is the EmojiVoto Application </h2>\n<br />\n\nEmojivoto is a sample microservice application that allows users to vote for their favorite emoji.\nIt displays votes received on a leaderboard. Emojivoto has no dependencies on Linkerd, but will run\nfine either on or off the service mesh.\n\nA sidecar injector is used for automating the injection of the Linkerd proxy into your application's pod spec. The Kubernetes admission controller enforces this behavior send\nsending a webhook request the the sidecar injector every time a pod is to be scheduled. This injector inspects resources for a Linkerd-specific annotation (linkerd.io/inject: enabled).\nWhen that annotation exists, the injector mutates the pod's specification and adds both an init container as well as a sidecar containing the proxy itself.\n\nThe Linkerd sidecar proxy can be either manually or automatically injected into your application's pods. This can be done from the meshery dashboard for namespace globally by,\n\n1. Using Meshery, navigate to the Linkerd management page.\n1. Click the (+) icon on the `Configure Application` card and select `Annotate Namespace` from the list.\n\nAs part of Linkerd deployment in [Previous chapter](./getting-started), you have deployed the sidecar injector.\nTo verify, execute this command:\n\n```sh\nkubectl get deployment linkerd-proxy-injector -n linkerd\n```\n\nOutput:\n\n```sh\nNAME                     READY   UP-TO-DATE   AVAILABLE   AGE\nlinkerd-proxy-injector   1/1     1            1           9m49s\n```\n\nExamine the annotation added to the `linkerd` namespace:\n\n```sh\nkubectl describe namespace linkerd\n```\n\nOutput:\n\n```sh\nName:         linkerd\nLabels:       config.linkerd.io/admission-webhooks=disabled\n              linkerd.io/control-plane-ns=linkerd\n              linkerd.io/is-control-plane=true\nAnnotations:  linkerd.io/inject: disabled\nStatus:       Active\n\nNo resource quota.\n\nNo LimitRange resource.\n```\n\n<h3 className=\"chapter-sub-heading\"> Deploy the application</h3>\n\nUsing Meshery, navigate to the Linkerd management page.\n\n1. Enter `default` in the `Namespace` field.\n1. Click the (+) icon on the `Sample Application` card and select `Emojivoto Application` from the list.\n\nThis will do 3 things:\n\n1. Label the `emojivoto` namespace for sidecar injection.\n1. Deploys all the Emojivoto services and replica's in the `emojivoto` namespace.\n\n<br />\n<h3>Alternative: Manual installation </h3>\nFollow this if the above steps did not work for you\n<br />\n<br />\n\n<h4 className=\"chapter-alt-heading\"> Deploy emojivoto application</h4>\n\nInstall emojivoto into the emojivoto namespace by running:\n\n```sh\ncurl -sL https://run.linkerd.io/emojivoto.yml \\\n  | kubectl apply -f -\n```\n\nBefore we mesh it, let's take a look at the app.\nIf you're using Docker Desktop at this point you can visit http://localhost directly.\nIf you're not using Docker Desktop, we'll need to forward the web-svc service.\nTo forward web-svc locally to port 8080, you can run:\n\n```sh\nkubectl -n emojivoto port-forward svc/web-svc 8080:80\n```\n\n<h3 className=\"chapter-sub-heading\">\n  <a name=\"verify\"></a> Verify EmojiVoto deployment{\" \"}\n</h3>\n\n1. Verify that the deployments are all in a state of AVAILABLE before continuing.\n\n   ```sh\n   watch kubectl get deployment -n emojivoto\n   ```\n\n2. Inspect the details of the pods\n\n   Examine details of the pods:\n\n   ```sh\n   watch kubectl get po -n emojivoto\n   ```\n\n   Examine details of the services:\n\n   ```sh\n   watch kubectl get svc -n emojivoto\n   ```\n\n   Choose one of EmojiVoto's services (e.g. `web-svc`), and view it's sidecar configuration:\n\n   ```sh\n   kubectl get svc -n emojivoto\n\n   kubectl describe service svc/web-svc -n emojivoto\n   ```\n\nLet's look at the application deployment by port-forwarding the `web-svc` service:\n\n```sh\nkubectl port-forward svc/web-svc 8080:80  -n emojivoto\n```\n\nYou have onboarded emojivoto to the service mesh. Verify your data plane environment with this check:\n\n```sh\nlinkerd -n emojivoto check --proxy\n```\n\nLinkerd, in contrast to Istio annotates the resources (namespaces, deployment workloads) rather than labelling them.\n\n<h3>Deploy EmojiVoto </h3>\n\nApplying this yaml file included in the Linkerd package you collected in https://run.linkerd.io/emojivoto.yml\nwill deploy the sample app into your cluster.\n\n```sh\nkubectl apply -f https://run.linkerd.io/emojivoto.yml\n```\n\n<h4 className=\"chapter-alt-heading\">\n  Inject Linkerd proxy into the sample application\n</h4>\n\nThe emojivoto application is a standalone Kubernetes application that uses a mix of gRPC and\nHTTP calls to allow the users to vote on their favorite emojis, which means the\napplication can run standalone without support from linkerd service mesh. Now we will\nbe injecting linkerd into our sample application\n\n```sh\nkubectl get -n emojivoto deploy -o yaml \\\n | linkerd inject - \\\n | kubectl apply -f -\n```\n\nOr...\n\n```sh\nkubectl -n emojivoto patch -f https://run.linkerd.io/emojivoto.yml -p '\nspec:\n  template:\n    metadata:\n      annotations:\n        linkerd.io/inject: enabled\n'\n```\n\nEither of these commands retrieve all of the deployments running in the emojivoto namespace, runs the manifest\nthrough linkerd inject, and then reapplies it to the cluster. The linkerd inject command adds annotations to the pod spec\ninstructing Linkerd to add (“inject”) the proxy as a container to the pod spec.\n\nYou've now added Linkerd to existing services! Just as with the control plane, it\nis possible to verify that everything worked the way it should with the data plane.\nTo do this check, run:\n\n```sh\nlinkerd -n emojivoto check --proxy\n```\n\n</ChapterStyle>\n","frontmatter":{"chapterTitle":"Deploy a sample application","description":"Meshery is the cloud native management plane which offers lifecycle, configuration, and performance management of service meshes and their workloads."},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/deploy-an-application","course":"introduction-to-service-meshes","learnpath":"mastering-service-meshes-for-developers","chapter":"deploy-an-application"}},"course":{"nodes":[{"frontmatter":{"courseTitle":"Introduction to Service Meshes - Hands On","meshesYouLearn":[{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/731763d720780a49c2ffdfede8c28f4b/istio.svg"},"name":"Istio"},{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/b4f4020971de42f6fb2497075a67f325/linkerd.svg"},"name":"Linkerd"}]},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes"}}]},"TOC":{"nodes":[{"frontmatter":{"order":8,"chapterTitle":"Circuit Breaking"},"fields":{"section":"istio","chapter":"circuit-breaking"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"istio","chapter":"conclusion"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"istio","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Istio Ingress Gateway"},"fields":{"section":"istio","chapter":"expose-services"}},{"frontmatter":{"order":6,"chapterTitle":"Fault Injection"},"fields":{"section":"istio","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"istio","chapter":"getting-started"}},{"frontmatter":{"order":7,"chapterTitle":"Mutual TLS & Identity Verification"},"fields":{"section":"istio","chapter":"mutual-tls"}},{"frontmatter":{"order":4,"chapterTitle":"Observability"},"fields":{"section":"istio","chapter":"observability"}},{"frontmatter":{"order":5,"chapterTitle":"Request Routing and Canary Testing"},"fields":{"section":"istio","chapter":"routing-and-canary"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"linkerd","chapter":"conclusion"}},{"frontmatter":{"order":4,"chapterTitle":"Linkerd Dashboard"},"fields":{"section":"linkerd","chapter":"dashboard"}},{"frontmatter":{"order":5,"chapterTitle":"Debugging (Optional)"},"fields":{"section":"linkerd","chapter":"debugging"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"linkerd","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Linkerd Ingress"},"fields":{"section":"linkerd","chapter":"expose-services"}},{"frontmatter":{"order":8,"chapterTitle":"Fault Injection"},"fields":{"section":"linkerd","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"linkerd","chapter":"getting-started"}},{"frontmatter":{"order":6,"chapterTitle":"Observability"},"fields":{"section":"linkerd","chapter":"observability"}},{"frontmatter":{"order":7,"chapterTitle":"Traffic Splitting using SMI and Linkerd"},"fields":{"section":"linkerd","chapter":"traffic-splitting"}}]},"serviceMeshesList":{"nodes":[{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}}]}},"pageContext":{"learnpath":"mastering-service-meshes-for-developers","slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/deploy-an-application","course":"introduction-to-service-meshes","section":"linkerd","chapter":"deploy-an-application","pageType":"chapter","frontmatter":{"docType":"Chapter","chapterTitle":"Deploy a sample application","description":"Meshery is the cloud native management plane which offers lifecycle, configuration, and performance management of service meshes and their workloads.","videos":4,"lectures":12,"order":2}}},"staticQueryHashes":["1376321266","1485533831","2848499768","4047814605","961506260"],"matchPath":"/learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/deploy-an-application.html"}