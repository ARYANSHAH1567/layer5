{"componentChunkName":"component---src-templates-learn-chapter-js-content-file-path-home-runner-work-layer-5-layer-5-content-learn-mastering-service-meshes-for-developers-introduction-to-service-meshes-linkerd-fault-injection-mdx","path":"/learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection.html.html","result":{"data":{"chapter":{"body":"\n\n\n<ChapterStyle>\n\n<h2 className=\"chapter-sub-heading\">Fault Injection using SMI in Linkerd</h2>\n\nApplication failure injection is a form of chaos engineering where we artificially increase the error rate of certain services in a microservice application to see what impact that has on the system as a whole. Traditionally, you would need to add some kind of failure injection library into your service code in order to do application failure injection. Thankfully, the service mesh gives us a way to inject application failures without needing to modify or rebuild our services at all.\n\n<h3 className=\"chapter-sub-heading\">\n  Using SMI Traffic Split API to inject errors\n</h3>\n\nWe can easily inject application failures by using the Traffic Split API of the Service Mesh Interface. This allows us to do failure injection in a way that is implementation agnostic and works across service meshes.\n\nWe will do this first by deploying a new service which only return errored responses. We will be using a simple NGINX service which has configured to only return HTTP 500 responses.\n\nWe will then create a traffic split which would redirect the service mesh to send a sample percentage of traffic to the error service instead, let's say 20% of service's traffic to error, then we would have injected an artificial 20% error rate in service.\n\n<h3 className=\"chapter-sub-heading\">Deploy Linkerd Books Application</h3>\n\nWe will be deploying [Linkerd Books application](https://github.com/BuoyantIO/booksapp) for this part of the demo\n\nUse meshery to deploy the bookinfo application :\n\n- In Meshery, navigate to the Linkerd adapter's management page from the left nav menu.\n- On the Linkerd adapter's management page, please enter `default` in the `Namespace` field.\n- Then, click the (+) icon on the `Sample Application` card and select `Books Application` from the list.\n\nInject linkerd into sample application using\n\n```sh\nlinkerd inject https://run.linkerd.io/booksapp.yml | kubectl apply -f -\n```\n\nIn the following, one of the service has already beeen configured with the error let's remove the error rate from the same :\n\n```sh\nkubectl edit deploy/authors\n```\n\nRemove the lines\n\n```sh\n- name: FAILURE_RATE\n  value: \"0.5\n```\n\nNow if you will see `linkerd stat`, the success rate would be 100%\n\n```sh\nlinkerd stat deploy\n```\n\n<h3 className=\"chapter-sub-heading\"> Create the errored service</h3>\n\nNow we will create our error service, we have NGINX pre-configured to only respond with HTTP 500 status code\n\n```sh\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: error-injector\n  labels:\n    app: error-injector\nspec:\n  selector:\n    matchLabels:\n      app: error-injector\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: error-injector\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:alpine\n          ports:\n          - containerPort: 80\n            name: nginx\n            protocol: TCP\n          volumeMounts:\n            - name: nginx-config\n              mountPath: /etc/nginx/nginx.conf\n              subPath: nginx.conf\n      volumes:\n        - name: nginx-config\n          configMap:\n            name: error-injector-config\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: error-injector\n  name: error-injector\nspec:\n  clusterIP: None\n  ports:\n  - name: service\n    port: 7002\n    protocol: TCP\n    targetPort: nginx\n  selector:\n    app: error-injector\n  type: ClusterIP\n---\napiVersion: v1\ndata:\n nginx.conf: |2\n\n    events {\n        worker_connections  1024;\n    }\n\n    http {\n        server {\n            location / {\n                return 500;\n            }\n        }\n    }\nkind: ConfigMap\nmetadata:\n  name: error-injector-config\n```\n\nAfter deploying the above errored service, we will create a traffic split resource which will be responsible to direct 20% of the book service to the error.\n\n```sh\napiVersion: split.smi-spec.io/v1alpha3\nkind: TrafficSplit\nmetadata:\n  name: fault-inject\nspec:\n  service: books\n  backends:\n  - service: books\n    weight: 800m\n  - service: error-injector\n    weight: 200m\n```\n\nYou can now see an 20% error rate for calls from webapp to books\n\n```sh\nlinkerd routes deploy/webapp --to service/books\n```\n\nYou can also see the error on the web browser\n\n```sh\nkubectl port-forward deploy/webapp 7000 && open http://localhost:7000\n```\n\nIf you refresh page few times, you will see `Internal Server Error`.\n\n<h3 className=\"chapter-alt-heading\">Cleanup</h3>\n\n```sh\nkubectl delete trafficsplit/error-split\n```\n\n- Remove the book info application from the `Meshery Dashboard` by clicking on the `trash icon` in the `sample application` card on the linkerd adapters' page.\n\n</ChapterStyle>\n","frontmatter":{"chapterTitle":"Fault Injection","description":"Meshery is the cloud native management plane which offers lifecycle, configuration, and performance management of service meshes and their workloads."},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection","course":"introduction-to-service-meshes","learnpath":"mastering-service-meshes-for-developers","chapter":"fault-injection"}},"course":{"nodes":[{"frontmatter":{"courseTitle":"Introduction to Service Meshes - Hands On","meshesYouLearn":[{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/731763d720780a49c2ffdfede8c28f4b/istio.svg"},"name":"Istio"},{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/b4f4020971de42f6fb2497075a67f325/linkerd.svg"},"name":"Linkerd"}]},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes"}}]},"TOC":{"nodes":[{"frontmatter":{"order":8,"chapterTitle":"Circuit Breaking"},"fields":{"section":"istio","chapter":"circuit-breaking"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"istio","chapter":"conclusion"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"istio","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Istio Ingress Gateway"},"fields":{"section":"istio","chapter":"expose-services"}},{"frontmatter":{"order":6,"chapterTitle":"Fault Injection"},"fields":{"section":"istio","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"istio","chapter":"getting-started"}},{"frontmatter":{"order":7,"chapterTitle":"Mutual TLS & Identity Verification"},"fields":{"section":"istio","chapter":"mutual-tls"}},{"frontmatter":{"order":4,"chapterTitle":"Observability"},"fields":{"section":"istio","chapter":"observability"}},{"frontmatter":{"order":5,"chapterTitle":"Request Routing and Canary Testing"},"fields":{"section":"istio","chapter":"routing-and-canary"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"linkerd","chapter":"conclusion"}},{"frontmatter":{"order":4,"chapterTitle":"Linkerd Dashboard"},"fields":{"section":"linkerd","chapter":"dashboard"}},{"frontmatter":{"order":5,"chapterTitle":"Debugging (Optional)"},"fields":{"section":"linkerd","chapter":"debugging"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"linkerd","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Linkerd Ingress"},"fields":{"section":"linkerd","chapter":"expose-services"}},{"frontmatter":{"order":8,"chapterTitle":"Fault Injection"},"fields":{"section":"linkerd","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"linkerd","chapter":"getting-started"}},{"frontmatter":{"order":6,"chapterTitle":"Observability"},"fields":{"section":"linkerd","chapter":"observability"}},{"frontmatter":{"order":7,"chapterTitle":"Traffic Splitting using SMI and Linkerd"},"fields":{"section":"linkerd","chapter":"traffic-splitting"}}]},"serviceMeshesList":{"nodes":[{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}}]}},"pageContext":{"learnpath":"mastering-service-meshes-for-developers","slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection","course":"introduction-to-service-meshes","section":"linkerd","chapter":"fault-injection","pageType":"chapter","frontmatter":{"docType":"Chapter","chapterTitle":"Fault Injection","description":"Meshery is the cloud native management plane which offers lifecycle, configuration, and performance management of service meshes and their workloads.","videos":4,"lectures":12,"order":8}}},"staticQueryHashes":["1376321266","1485533831","2848499768","4047814605","961506260"],"matchPath":"/learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection.html"}