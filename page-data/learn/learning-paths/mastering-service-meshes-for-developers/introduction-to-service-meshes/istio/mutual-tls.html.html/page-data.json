{"componentChunkName":"component---src-templates-learn-chapter-js-content-file-path-home-runner-work-layer-5-layer-5-content-learn-mastering-service-meshes-for-developers-introduction-to-service-meshes-istio-mutual-tls-mdx","path":"/learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/istio/mutual-tls.html.html","result":{"data":{"chapter":{"body":"\n\n\n<ChapterStyle>\n\nIstio provides transparent mutual TLS to services inside the service mesh where both the client and the server authenticate each others' certificates as part of the TLS handshake. As part of this course, we have deployed Istio with mTLS.\n\nBy default istio sets mTLS in `PERMISSIVE` mode which allows plain text traffic to be sent and accepted by a mesh. We first disallow plain text traffic using `PeerAuthentication` and setting mTLS mode to STRICT.\n\n<h2 className=\"chapter-sub-heading\"> Confirm mTLS is being enforced</h2>\n\nThis can be easily done by executing a simple command:-\n\n```sh\nkubectl get peerauthentication --all-namespaces\n```\n\n<h2 className=\"chapter-sub-heading\"> Verify mTLS</h2>\n\nCitadel is Istioâ€™s key management service. As a first step, confirm that Citadel is up and running:\n\n```sh\nkubectl get deploy -l istio=citadel -n istio-system\n```\n\nOutput will be similar to:\n\n```\nNAME            READY   UP-TO-DATE   AVAILABLE   AGE\nistio-citadel   1/1     1            1           3m23s\n```\n\nTo experiment with mTLS, let's do so by logging into the sidecar proxy of the `productpage` pod by executing this command:\n\n```sh\nkubectl exec -it $(kubectl get pod | grep productpage | awk '{ print $1 }') -c istio-proxy -- /bin/bash\n```\n\nWe are now in the proxy of the `productpage` pod. Check that all the ceritificates are loaded in this proxy:\n\n```sh\nls /etc/certs/\n```\n\nYou should see 3 entries:\n\n```sh\ncert-chain.pem  key.pem  root-cert.pem\n```\n\nNow, try to make a curl call to the `details` service over HTTP:\n\n```sh\ncurl http://details:9080/details/0\n```\n\nSince, we have TLS between the sidecar's, an HTTP call will not work. The request will timeout. You will see an error like the one below:\n\n```sh\ncurl: (7) Failed to connect to details port 9080: Connection timed out\n```\n\nLet us try to make a curl call to the details service over HTTPS but **WITHOUT** certs:\n\n```sh\ncurl https://details:9080/details/0 -k\n```\n\nThe request will be denied and you will see an error like the one below:\n\n```sh\ncurl: (16) SSL_write() returned SYSCALL, errno = 104\n```\n\nNow, let us use curl over HTTPS with certificates to the details service:\n\n```sh\ncurl https://details:9080/details/0 -v --key /etc/certs/key.pem --cert /etc/certs/cert-chain.pem --cacert /etc/certs/root-cert.pem -k\n```\n\nOutput will be similar to this:\n\n```sh\n*   Trying 10.107.35.26...\n* Connected to details (10.107.35.26) port 9080 (#0)\n* found 1 certificates in /etc/certs/root-cert.pem\n* found 0 certificates in /etc/ssl/certs\n* ALPN, offering http/1.1\n* SSL connection using TLS1.2 / ECDHE_RSA_AES_128_GCM_SHA256\n*        server certificate verification SKIPPED\n*        server certificate status verification SKIPPED\n* error fetching CN from cert:The requested data were not available.\n*        common name:  (does not match 'details')\n*        server certificate expiration date OK\n*        server certificate activation date OK\n*        certificate public key: RSA\n*        certificate version: #3\n*        subject: O=#1300\n*        start date: Thu, 26 Oct 2018 14:36:56 GMT\n*        expire date: Wed, 05 Jan 2019 14:36:56 GMT\n*        issuer: O=k8s.cluster.local\n*        compression: NULL\n* ALPN, server accepted to use http/1.1\n> GET /details/0 HTTP/1.1\n> Host: details:9080\n> User-Agent: curl/7.47.0\n> Accept: */*\n>\n< HTTP/1.1 200 OK\n< content-type: application/json\n< server: envoy\n< date: Thu, 07 Jun 2018 15:19:46 GMT\n< content-length: 178\n< x-envoy-upstream-service-time: 1\n< x-envoy-decorator-operation: default-route\n<\n* Connection #0 to host details left intact\n{\"id\":0,\"author\":\"William Shakespeare\",\"year\":1595,\"type\":\"paperback\",\"pages\":200,\"publisher\":\"PublisherA\",\"language\":\"English\",\"ISBN-10\":\"1234567890\",\"ISBN-13\":\"123-1234567890\"}\n```\n\nThis proves the existence of mTLS between the services on the Istio mesh.\n\nNow lets come out of the container before we go to the next section:\n\n```sh\nexit\n```\n\n<h2 className=\"chapter-sub-heading\">\n  Secure Production Identity Framework for Everyone (SPIFFE)\n</h2>\n<br />\nIstio uses [SPIFFE](https://spiffe.io/) to assert the identify of workloads on\nthe cluster. SPIFFE consists of a notion of identity and a method of proving it.\nA SPIFFE identity consists of an authority part and a path. The meaning of the\npath in spiffe land is implementation defined. In k8s it takes the form\n`/ns/$namespace/sa/$service-account` with the expected meaning. A SPIFFE\nidentify is embedded in a document. This document in principle can take many\nforms but currently the only defined format is x509.\n\nTo start our investigation, let us check if the certs are in place in the productpage sidecar:\n\n```sh\nkubectl exec $(kubectl get pod -l app=productpage -o jsonpath={.items..metadata.name}) -c istio-proxy -- ls /etc/certs\n```\n\nOutput will be similar to:\n\n```sh\ncert-chain.pem\nkey.pem\nroot-cert.pem\n```\n\nMac users, MacOS should have openssl available. If your machine does not have openssl install, install it using your preferred method.\n\nHere is one way to install it on RHEL or CentOS or its derivatives:\n\n```sh\nsudo yum install -y openssl-devel\n```\n\nHere is one way to install it on Ubuntu or Debian or its derivatives:\n\n```sh\nsudo apt install -y libssl-dev\n```\n\nNow that we have found the certs, let us verify the certificate of productpage sidecar by running this command:\n\n```sh\nkubectl exec $(kubectl get pod -l app=productpage -o jsonpath={.items..metadata.name}) -c istio-proxy -- cat /etc/certs/cert-chain.pem | openssl x509 -text -noout  | grep Validity -A 2\n```\n\nOutput will be similar to:\n\n```sh\n    Not Before: Sep 23 17:32:28 2019 GMT\n    Not After : Dec 22 17:32:28 2019 GMT\n```\n\nLets also verify the URI SAN:\n\n```sh\nkubectl exec $(kubectl get pod -l app=productpage -o jsonpath={.items..metadata.name}) -c istio-proxy -- cat /etc/certs/cert-chain.pem | openssl x509 -text -noout  | grep 'Subject Alternative Name' -A 1\n```\n\nOutput will be similar to:\n\n```sh\nX509v3 Subject Alternative Name: critical\n    URI:spiffe://cluster.local/ns/default/sa/bookinfo-productpage\n```\n\n</ChapterStyle>\n","frontmatter":{"chapterTitle":"Mutual TLS & Identity Verification","description":"Meshery is the cloud native management plane which offers lifecycle, configuration, and performance management of service meshes and their workloads."},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/istio/mutual-tls","course":"introduction-to-service-meshes","learnpath":"mastering-service-meshes-for-developers","chapter":"mutual-tls"}},"course":{"nodes":[{"frontmatter":{"courseTitle":"Introduction to Service Meshes - Hands On","meshesYouLearn":[{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/731763d720780a49c2ffdfede8c28f4b/istio.svg"},"name":"Istio"},{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/b4f4020971de42f6fb2497075a67f325/linkerd.svg"},"name":"Linkerd"}]},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes"}}]},"TOC":{"nodes":[{"frontmatter":{"order":8,"chapterTitle":"Circuit Breaking"},"fields":{"section":"istio","chapter":"circuit-breaking"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"istio","chapter":"conclusion"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"istio","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Istio Ingress Gateway"},"fields":{"section":"istio","chapter":"expose-services"}},{"frontmatter":{"order":6,"chapterTitle":"Fault Injection"},"fields":{"section":"istio","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"istio","chapter":"getting-started"}},{"frontmatter":{"order":7,"chapterTitle":"Mutual TLS & Identity Verification"},"fields":{"section":"istio","chapter":"mutual-tls"}},{"frontmatter":{"order":4,"chapterTitle":"Observability"},"fields":{"section":"istio","chapter":"observability"}},{"frontmatter":{"order":5,"chapterTitle":"Request Routing and Canary Testing"},"fields":{"section":"istio","chapter":"routing-and-canary"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"linkerd","chapter":"conclusion"}},{"frontmatter":{"order":4,"chapterTitle":"Linkerd Dashboard"},"fields":{"section":"linkerd","chapter":"dashboard"}},{"frontmatter":{"order":5,"chapterTitle":"Debugging (Optional)"},"fields":{"section":"linkerd","chapter":"debugging"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"linkerd","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Linkerd Ingress"},"fields":{"section":"linkerd","chapter":"expose-services"}},{"frontmatter":{"order":8,"chapterTitle":"Fault Injection"},"fields":{"section":"linkerd","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"linkerd","chapter":"getting-started"}},{"frontmatter":{"order":6,"chapterTitle":"Observability"},"fields":{"section":"linkerd","chapter":"observability"}},{"frontmatter":{"order":7,"chapterTitle":"Traffic Splitting using SMI and Linkerd"},"fields":{"section":"linkerd","chapter":"traffic-splitting"}}]},"serviceMeshesList":{"nodes":[{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}}]}},"pageContext":{"learnpath":"mastering-service-meshes-for-developers","slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/istio/mutual-tls","course":"introduction-to-service-meshes","section":"istio","chapter":"mutual-tls","pageType":"chapter","frontmatter":{"docType":"Chapter","chapterTitle":"Mutual TLS & Identity Verification","description":"Meshery is the cloud native management plane which offers lifecycle, configuration, and performance management of service meshes and their workloads.","videos":4,"lectures":12,"order":7}}},"staticQueryHashes":["1376321266","1485533831","2848499768","4047814605","961506260"],"matchPath":"/learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/istio/mutual-tls.html"}